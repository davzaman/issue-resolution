# Run multiple stepped runs in parallel

https://github.com/guildai/guildai/issues/107

## Problem

There are couple problems here:

1. Stepped ops don't use the upstream run _they_ generate - they
   simply execute runs in the order presented and let Guild's op
   resolution logic take effect. This makes it impossible to run these
   in parallel as there's no guarantee that the latest run is the run
   generated by the stepped op.

2. Queues don't support running ops in parallel.

## Recreating

Requirements:

- guild<=0.7.0.rc3

### Recreating problem #1 (stepped ops uses wrong upstream)

Run each of the following commands in separate terminals,
approximately at the same time:

Command 1:

    $ guild run steps sleep=5 -y

Command 2 (in a separate terminal, approximately at the same time as
command 1):

    $ guild run steps sleep=1 -y

Command 2 will complete first, generating the expected result - the
downstream op will use the associated upstream op. Command 1 will
finish after command 2 but will use the upstream run from command 2.

The results from `guild runs` should look like this:

```
[1:8abba322]  downstream  2019-12-28 12:52:16  completed  upstream=666ea366
[2:727f087c]  downstream  2019-12-28 12:52:15  completed  upstream=666ea366
[3:666ea366]  upstream    2019-12-28 12:52:13  completed  sleep=1
[4:b4aa673a]  steps       2019-12-28 12:52:12  completed  sleep=1
[5:acce23d5]  upstream    2019-12-28 12:52:10  completed  sleep=5
[6:b454495c]  steps       2019-12-28 12:52:09  completed  sleep=5
```

The expexted result is that each downstream should use its
corresponding upstream run - not simply the latest available upstream.

### Recreating problem #2 (queue doesn't run operations in parallel)

This is a known limitation of the `queue` operation (at least as of
`0.7.0`).

## Workarounds

### Workaround problem #1 (stepped ops use wrong upstream)

This technique uses separate Guild home paths for each stepped
operation.

In separate terminals, run the following commands approximately at the
same time.

Command 1:

    $ guild -H scratch/steps-5 run steps sleep=5 -y

Command 2 (in a separate terminal, approximately at the same time as
command 1):

    $ guild -H scratch/steps-1 run steps sleep=1 -y

Each operation runs in isolation of one another using separate Guild
home locations.

You can list each set of runs by specifying the home path:

    $ guild -H scratch/steps-1 runs
    $ guild -H scratch/steps-5 runs

To import the runs, use `import`:

    $ guild import scratch/steps-1/runs --move
    $ guild import scratch/steps-5/runs --move

List the runs:

    $ guild runs

Each downstream uses the expected upstream. The output should look
like this:

```
[1:559aa800]  downstream  2019-12-28 13:03:20  completed  upstream=a21dbbcc
[2:f3bd758f]  downstream  2019-12-28 13:03:09  completed  upstream=0811701d
[3:a21dbbcc]  upstream    2019-12-28 13:03:09  completed  sleep=10
[4:9b8cd78f]  steps       2019-12-28 13:03:08  completed  sleep=10
[5:0811701d]  upstream    2019-12-28 13:03:07  completed  sleep=1
[6:03ee8c2d]  steps       2019-12-28 13:03:07  completed  sleep=1
```

### Workaround problem #2 (queue doesn't run operations in parallel)

Using separate Guild home paths for each series of runs effectively
isolated run sequences. This technique can be used to effectively
stage a sequence of operations using `steps`.

To queue a series of operations, simply run a steppped operation in
the background.

    $ guild -H <some unique location> run steps sleep=<some val> --background

To check status on the sequence of operations:

    $ guild -H <some unique location> runs

To import the runs:

    $ guild -H <some unique location>/runs import

If you're done with the unique Guild home, delete it:

    $ rm -rf <some unique location>

## Update 2019/12/29 - Can't set Guild home for remote runs

The approach outlined above, which relies on isolating parallel runs
using separate Guild home locations, is not currently feasible for
remote runs.

1. There's no way to set Guild home for a specific run. While Guild
   home can be set in user config, it's unreasonable to require file
   edits to set per-run information.

2. Even if this were possible, merging runs as outlined above on
   remote systems is not directly supported. It requires a cumbersome
   pull/push to consolidate runs.

## Update 2019/12/30 - Direct solution for problems 1 and 2

Rather than pursue run isolation using separate Guild homes, we've
opted to directly solve problems 1 and 2 above. See Fix below for
details.

## Fix

As of 0.7.0.rc4, Guild now supports two features that address problems
1 and 2 above.

### Fix for problem #1 (stepped ops use wrong upstream)

As of 0.7.0.rc4, by default, steps only consider child runs when
resolving requirements. This effectively isolated all runs within a
stepped operation. This behavior can be changed by setting
`isolate-runs` to `no` for any operation that needs to resolve runs
outside the stepped parent operation.

To illustate, follow the steps for recreating the problem above. Using
the `steps` operation, the correct behavior is implemented.

To illustrate the old behavior, follow the same steps but run
`steps-no-isolate` instead. The incorrect behavior is exhibited.

### Fix for problem #2 (queue doesn't run operations in parallel)

As of 0.7.0.rc4, `queue` operations may be run concurrently, either in
separate terminals or as background processes, to process staged runs
in parallel.

Note that `ignore-running` must be set to `yes` when running more than
one queue for a given environment. If this flag is not set, only one
staged run will be started at a time. The default behavior assumes
that runs should have full access to the system. If it's safe to run
operations concurrently, `igore-running` is used to bypass this check.

To illustrate concurrent runs, start multiple queues, either in
separate terminals or in the background, and stage multiple `steps`
operations.
